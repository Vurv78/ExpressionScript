package lib;

import lib.Error.Trace;
import lib.Type.E2Value;

typedef Instruction = {
	id: Instr,
	trace: Trace,
	args: InstructionArgs // Arguments to be passed to the compiler.
}

typedef InstructionArgs = Array<Any>;

typedef IndexResult = { type: Null<String>, trace: Trace, key: Instruction };
typedef SwitchCases = Array<{?match: Instruction, block: Instruction}>;
typedef FunctionParams = Array<{name: String, type: String}>;

// To avoid Dynamic, make an enum of all possible instruction arguments to pass.
// This is since we use reflection instead of properly calling each function.
enum InstructionArgE {
	ValueBool(i: Bool);
	ValueString(i: String);
	E2Value(i: E2Value);

	SwitchCases(i: SwitchCases);

	ArrInstruction(i: Array<Instruction>);
	Instruction(i: Instruction);
	MapInstruction(i: Map<Instruction, Instruction>);

	IndexResult(i: IndexResult);
	FunctionParams(i: FunctionParams);
}

// TODO: Use a more elegant autogenerated macro instead of this manual implementation
abstract InstructionArg(InstructionArgE) from InstructionArgE to InstructionArgE {
	@:from inline static function fromA(a:Bool):InstructionArg return ValueBool(a);
	@:from inline static function fromB(b:String):InstructionArg return ValueString(b);
	@:from inline static function fromC(c:E2Value):InstructionArg return E2Value(c);
	@:from inline static function fromD(d:SwitchCases):InstructionArg return SwitchCases(d);
	@:from inline static function fromE(e:Array<Instruction>):InstructionArg return ArrInstruction(e);
	@:from inline static function fromF(f:Instruction):InstructionArg return Instruction(f);
	@:from inline static function fromG(g:Map<Instruction, Instruction>):InstructionArg return MapInstruction(g);
	@:from inline static function fromH(h:IndexResult):InstructionArg return IndexResult(h);
	@:from inline static function fromI(i:FunctionParams):InstructionArg return FunctionParams(i);

	@:to inline function toA():Null<Bool> return switch(this) { case ValueBool(a): a; default: null; }
	@:to inline function toB():Null<String> return switch(this) { case ValueString(a): a; default: null; }
	@:to inline function toC():Null<E2Value> return switch(this) { case E2Value(a): a; default: null; }
	@:to inline function toD():Null<SwitchCases> return switch(this) { case SwitchCases(a): a; default: null; }
	@:to inline function toE():Null<Array<Instruction>> return switch(this) { case ArrInstruction(a): a; default: null; }
	@:to inline function toF():Instruction return switch(this) { case Instruction(a): a; default: null; }
	@:to inline function toG():Null<Map<Instruction, Instruction>> return switch(this) { case MapInstruction(a): a; default: null; }
	@:to inline function toH():Null<IndexResult> return switch(this) { case IndexResult(a): a; default: null; }
	@:to inline function toI():Null<FunctionParams> return switch(this) { case FunctionParams(a): a; default: null; }
}

@:enum
enum Instr {
	Root; // "root" --- seq
	Break; // "break"
	Continue; // "continue"
	For; // "for"
	While; // "while"
	If; // "if"
	TernaryDefault; // ?:
	Ternary; // "ternary"
	Call; // "call"
	Stringcall; // "stringcall"
	Methodcall; // "methodcall"
	Assign; // "assign"
	LAssign; // "lassign"
	IndexGet; // "index_get"
	IndexSet; // "index_set"

	Add; // "add"
	Sub; // "sub"
	Mul; // "mul"
	Div; // "div"
	Mod; // "mod"
	Exp; // "exp"
	Equal; // "equals"
	NotEqual; // "nequals"
	GreaterThanEq; // "geq"
	LessThanEq; // "leq"
	GreaterThan; // "gt"
	LessThan; // "lt"

	BAnd; // "band"
	Bor; // "bor"
	BXor; // "bxor"
	BShl; // "bshl"
	BShr; // "bshr"

	Increment; // "increment"
	Decrement; // "decrement"
	Negative; // "negative"
	Not; // "not"
	And; // "and"
	Or; // "or"

	Triggered; // "triggered" // (~) Kept for backwards compat.
	Delta; // "delta" // $
	Connected; // "connected" // (->) Kept for backwards compat.
	Literal; // "literal"
	Var; // "var" // Variable reference
	Foreach; // "foreach"
	Function; // "function"
	Return; // "return"
	KVTable; // "kvtable"
	KVArray; // "kvarray"
	Switch; // "switch"
	Include; // "include"
	Try; // "try"
	GroupedEquation; // "grouped_equation"
}