package lib;

using haxe.ds.Option;
import safety.IllegalArgumentException;
import lib.Error.Trace;
import lib.Type.E2Value;
using Safety;

typedef Instruction = {
	id: Instr,
	trace: Trace,
	args: InstructionArgs // Arguments to be passed to the compiler.
}

typedef InstructionArgs = Array<Null<InstructionArg>>;

typedef IndexResult = { type: Null<String>, trace: Trace, key: Instruction };
typedef SwitchCases = Array<{?match: Instruction, block: Instruction}>;
typedef FunctionParams = Array<{name: String, type: String}>;

enum Optional {
	String(i: Null<String>);
	Instruction(i: Option<Instruction>);
}

// To avoid Dynamic, make an enum of all possible instruction arguments to pass.
// This is since we use reflection instead of properly calling each function.
enum InstructionArgE {
	ValBool(i: Bool);
	ValString(i: String);
	E2Value(i: E2Value);

	SwitchCases(i: SwitchCases);

	ArrInstruction(i: Array<Instruction>);
	ArrInstructionArg(i: Array<InstructionArg>);

	SoleInstruction(i: Instruction);
	MapInstruction(i: Map<Instruction, Instruction>);

	IndexResult(i: IndexResult);
	FunctionParams(i: FunctionParams);

	Maybe(i: Optional);
}

final NULL_GUARD = new IllegalArgumentException("Found a null value being transported in an instruction");

// TODO: Use a more elegant autogenerated macro instead of this manual implementation
@:forward
abstract InstructionArg(InstructionArgE) from InstructionArgE to InstructionArgE {
	@:from inline static function fromA(i:Bool):InstructionArg return ValBool(i);
	@:from inline static function fromB(i:String):InstructionArg return ValString(i);
	@:from inline static function fromC(i:E2Value):InstructionArg return E2Value(i);
	@:from inline static function fromD(i:SwitchCases):InstructionArg return SwitchCases(i);
	@:from inline static function fromE(i:Array<Instruction>):InstructionArg return ArrInstruction(i);
	@:from inline static function fromF(i:Instruction):InstructionArg return SoleInstruction(i);
	@:from inline static function fromG(i:Map<Instruction, Instruction>):InstructionArg return MapInstruction(i);
	@:from inline static function fromH(i:IndexResult):InstructionArg return IndexResult(i);
	@:from inline static function fromI(i:FunctionParams):InstructionArg return FunctionParams(i);

	@:to inline function toA():Bool return switch(this) { case ValBool(o): o; default: throw NULL_GUARD; }
	@:to inline function toB():String return switch(this) { case ValString(o): o; default: throw NULL_GUARD; }
	@:to inline function toC():E2Value return switch(this) { case E2Value(o): o; default: throw NULL_GUARD; }
	@:to inline function toD():SwitchCases return switch(this) { case SwitchCases(o): o; default: throw NULL_GUARD; }
	@:to inline function toE():Null<Array<Instruction>> return switch(this) { case ArrInstruction(o): o; default: null; }
	@:to inline function toF():Instruction return switch(this) { case SoleInstruction(o): o; default: throw NULL_GUARD; }
	@:to inline function toG():Null<Map<Instruction, Instruction>> return switch(this) { case MapInstruction(o): o; default: null; }
	@:to inline function toH():IndexResult return switch(this) { case IndexResult(o): o; default: throw NULL_GUARD; }
	@:to inline function toI():FunctionParams return switch(this) { case FunctionParams(o): o; default: throw NULL_GUARD; }
}

@:enum
enum Instr {
	Root;
	Break; // "break"
	Continue; // "continue"
	For; // "for"
	While; // "while"
	If; // "if"
	TernaryDefault; // ?:, "Cnd"
	Ternary; // "ternary"
	Call; // "call"
	Stringcall; // "stringcall"
	Methodcall; // "methodcall"
	Assign; // "assign"
	LAssign; // "lassign"
	IndexGet; // "index_get"
	IndexSet; // "index_set"

	Add; // "add"
	Sub; // "sub"
	Mul; // "mul"
	Div; // "div"
	Mod; // "mod"
	Exp; // "exp"
	Equal; // "equals"
	NotEqual; // "nequals"
	GreaterThanEq; // "geq"
	LessThanEq; // "leq"
	GreaterThan; // "gt"
	LessThan; // "lt"

	BAnd; // "band"
	Bor; // "bor"
	BXor; // "bxor"
	BShl; // "bshl"
	BShr; // "bshr"

	Increment; // "increment"
	Decrement; // "decrement"
	Negative; // "negative"
	Not; // "not"
	And; // "and"
	Or; // "or"

	Triggered; // "triggered" // (~) Kept for backwards compat.
	Delta; // "delta" // $
	Connected; // "connected" // (->) Kept for backwards compat.
	Literal; // "literal"
	Var; // "var" // Variable reference
	Foreach; // "foreach"
	Function; // "function"
	Return; // "return"
	KVTable; // "kvtable"
	KVArray; // "kvarray"
	Switch; // "switch"
	Include; // "include"
	Try; // "try"
	GroupedEquation; // "grouped_equation"
}